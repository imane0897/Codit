# 支持高并发访问的在线测试系统设计与开发

## 摘要

在线测试系统起源于ACM国际大学生程序设计竞赛（ACM/ICPC），是一种基于黑盒测试原理对计算机程序正确行进行判定的自动化程序。用户登录系统提交相关题目的源代码，系统会根据用户提交的代码进行编译和执行，并即时地返回评测的结果。现在，大多数学校都研发并拥有了自己的在线评测平台，如POJ、HDOJ等，用户可以在线提交多种程序的源代码（如C、C++、Java等），或者将学校的课程放在在线测试系统上进行平时的训练和考试。由于在线测试系统事先针对每道题目设计了全面的测试用例，因此能够避免学生将错误的程序当成正确的。实践说明，在线测试系统能够极大地激发学生的编程热情，提高学生的程序设计能力。

随着Web 2.0应用的兴起和移动设备的持续增长，互联网迎来了爆炸式的发展，不仅是互联网用户成几何倍数增长，网页内容也更加丰富并且能够与用户之间进行交互。与此同时，Web系统承载了巨大的压力。如何利用有限的硬件资源和服务器带宽，设计出性能良好的Web系统，提高网站的可用性，已成为各大网站和研究的重点。

关键字：高并发，在线测试系统，Golang

## Abstract

Online Judge is an automatic program aimming to judge source codes based on black  comes from ACM/ICPC

Keywords: cocurrency, Online Judge, Golang

## 1. 引言

在线测试系统由于需要实时对使用者提交的源代码进行编译、运行，同时又要完成大量Web请求的并发访问，所以系统对服务器系统的性能要求很高。普通的计算机服务器仅可以进行小规模的练习，而对于在线人数成百上千的大型比赛就无力应对了。虽然可以对Web服务器、数据库服务器、判题服务器进行分机运行，实现一个分布式运算系统，但是对于普通大学和科研机构，购买数量繁多的服务器又是一个经济上难以承受的负担。 通过设计一个性能良好的系统，可以有效提高网站的高并发性和高可用性，保证服务器在高并发状态下处于稳定状态，满足大型程序设计竞赛及上机考试的需求。同时也能够大幅减少教研机构在购买服务器上的经济投入。 随着互联网+时代的到来，互联网用户数量大幅度增长，用户与服务器之间的交互业务逻辑也更加复杂，流量峰值不断攀升，同时给服务器端提出了更高的要求，比如，铁路12306在春运期间的售票系统、淘宝在双十一时期的交易系统等，其并发访问量通常能够达到千万级别甚至上亿级别。因此，对于仅在一些特定时期存在高并发访问需求的系统，如何利用有限的物理资源来解决服务器高并发问题就成为服务器端编程的一个重要考验。

随着信息技术的不断发展，安全问题已成为系统开发中的重要一环。由于在线测试系统的使用者大多精通编程，因而在服务器上直接运行用户提交的代码是十分危险的，如果用户提交恶意代码（如死循环、访问系统文件、开启系统权限等），而服务器对此不加限制，就会导致服务器资源被耗尽甚至导致服务器被黑客远程控制。 应用沙盒技术，将用户代码全部放到沙盒环境中运行就可以避免服务器受到攻击， 维护系统安全。同时，监控用户程序对CPU及内存的使用，并将这些信息与判题结果一起返回给用户，让用户了解自己所编写的代码的运行效率，方便用户改进算法效率，提高自己的编程能力。 

## 2. 相关技术

### 2.1 Go 语言

#### 2.1.1 Goroutine

Go语言是一种并发的、带垃圾回收的、快速编译的语言，其内置的goroutine不仅具有协程轻量的特点，而且还提供了并发编程更加便利的模型，为并发的执行与通信提供了基本的支持。本文在设计并发编程时采用的是goroutine并发。在这里，根据阅读的文献，总结goroutine的特点如下：

(1) Gorouitine是协程的一种实现方式，所以和协程一样，占用的内存比线程要低很多。因为goroutine仅作为函数的入口，再加上为其分配的一个堆栈。所以，高并发的情况下我们可以很轻松创建成千上万个goroutine，Go语言中有内置的协程调度器对gorouine进行调度，所以它们并不是被操作系统所调度执行。

(2) Go语言在运行的过程中所启动的最大线程数是GOMAXPROCS（最大CPU核数）个来运行goroutine，这里排除了被系统调用所阻塞的线程。

(3) Goroutine之间是靠channel来进行通信的，所以goroutine属于协作式调度。若某个单独的goroutine没有进行channel通信，也没有I/O操作，在这种情况下还占用了CPU的资源，那就需要主动调用内置的Gosched()函数结束对CPU的占用。

(4) Goroutine 中的”无锁“的优点只有在单线程下有效，如果并行的核数大于一，并且协程间通过channel进行通信，Go 语言内置的运行库会负责加锁，从而对数据进行保护，这也就是为什么多核并行下的少量并发会和线程的效率不相上下。

(5) Goroutine最大的优势在于它真正的实现了用多协程编程实现多线程并发编程，使得用更少的资源实现更多的并发量成为了可能。随着Go语言版本的迭代以及CPU的不断升级，基于协程的高并发的实现也许会成为云计算的主流。

#### 2.1.2 Go语言的 CSP 并发模型

Go 语言实现了两种并发形式，一种是多线程共享内存，也就是 Java 或者 C++ 等语言中的多线程开发，另外一种是 Go 语言所特有的通信顺序处理 CSP (communicating sequential processes) 并发模型。CSP 是一个􏰁述并发系统的高级框架，不同于传统的多线程通过共享内存来通信，CSP 是以通信的方式来共享 内存。 

下图展示了一个最基本的 Golang CSP 并发模型: 

![image-20180520103614160](/var/folders/l5/q_72mh6n0qb48d9q8fygnymm0000gn/T/abnerworks.Typora/image-20180520103614160.png)

图 2.1.1 Go 语言 CSP 并发模型最基本的形式 

Go 语言的 CSP 并发模型，是通过 goroutine 和 channel 来实现的。 

Gorotines 是 Go 语言的一种调度机制，使用关键字go进行声明，以goroutine调度机制开启一个新的执行线程。它会在新创建的goroutine执行程序。在单个程序中，所有goroutines都是共享相同的地址空间。Goroutines是协同程序（coroutines）的一种运用。但它们不完全相同。一个goroutine是一个在由启动线程生成的单独线程上执行的函数，因此启动线程不会阻碍这个单独的线程。多个goroutine可以共享相同的操作系统线程。与协同程序不同，goroutine不能直接控制另一个goroutine。当一个特定的goroutine在读写访问时产生阻塞，Go语言的runtime负责隐式传输控制。相比于分配栈空间，goroutine更加轻量，花销更小。栈空间初始化很小，需要通过申请和释放堆空间来扩展内存。 

管道（Channel）是一个同步的驻在内存中的队列，goroutine和常规函数能使用此队列发送和接收带类型的值，通信通过管道被序列化。管道在默认的情况下是阻碍进程的。 如果对管道发送一个值，进程将被阻塞直到有人从这个管道接收它，反之亦然。使用缓存管道和select可以分别从两个方向避免阻塞。缓存管道是一种能保存一定数量值的管道，即使没有接收者，发送者也不会被阻塞，直到缓存满了。使用select声明可以让函数等待所有的管道，并且对第一个返回的管道回应。 

### 2.2 Ajax

AJAX（Asynchronous JavaScript and XML）即异步JavaScript和XML，是一种用于开发交互式网页的WEB开发技术。AJAX在浏览器和服务器之间异步传递请求和相应是通过XMLHtpReqeust对象来完成的，在Ajax中，可以向服务器发出请求而无须用户等待响应，这就称为一个异步请求。图 2.2.1 说明了 AJAX 在的过程流。 

![image-20180520110252538](/var/folders/l5/q_72mh6n0qb48d9q8fygnymm0000gn/T/abnerworks.Typora/image-20180520110252538.png)

图 2.2.1 AJAX 通信原理 

对于传统的Web页面和应用，每次用户点击页面上的某个部分时，浏览器都会向服务器发出一个请求，服务器再作出响应，返回一个完整的新页面。这种方法不仅浪费了网络带宽，也给服务器增加了压力，在表单信息的处理前后，网页中的界面样式往往没有大的改变，因此前后两个页面的大部分HTML代码都是相同的。不仅如此，由于每次交互都要与服务器进行通信，这样页面的响应时间也就受到了网络延迟的限制，如果网络状况不好，会出现页面长久不响应的情况。 

利用AJAX技术，我们可以仅向服务器发送服务器必须取回的数据，它使用一些基于XML的接口，并由浏览器上运行JavaScript来处理一些来自服务器的响应。这种做法大量减少了客户端与服务器之间的数据交换，而且一部分功能有客户端来实现，所以网页的响应速度也会显著提升，服务器需要处理的数据也大大减少。 

AJAX 的优势有:

 (1)采用异步通信模式，不需要刷新页面，降低了用户等待的过程，改善了用户浏览网页的感受。

(2)减少了服务器与客户端之间的数据传输，减少了带宽的占用。

(3)AJAX 使用的是 JavaScript，因此一部分工作由客户端来完成，降低了服务器 的负载。 

### 2.3 Docker

Docker是一个开源的应用容器引擎，属于Linux容器（Linux Containers，即LXC）的一种封装，提供简单易用的容器使用接口，是目前最流行的Linux容器解决方案。Docker将应用程序与该程序的依赖，打包在一个文件里面，运行这个文件，就会生成一个虚拟容器，程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了Docker，就可以不用担心环境问题，开发者可以发布自己的应用到任何流行的Linux机器上，也可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是Docker的最大优势，过去需要用数天乃至数周的任务，在Docker容器的处理下，只需要数秒就能完成。容器是完全使用沙箱机制，相互之间不会有任何接口，更重要的是容器性能开销极低。总的来说，Docker接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。

目前Docker的用途主要有三大类：

(1) 提供一次性的环境。比如，本地测试他人的文件，持续集成的时候提供单元测试和构建的环境。

(2) 提供弹性的云服务。因为Docker容器可以随开随关，很适合动态扩容和缩容。

(3) 组建服务器架构，通过多个容器，一台机器可以运行多个服务，因此在本机就可以模拟出微服务架构。

## 3 需求分析

### 3.1 系统需求概述

由于在线测试系统需要实时对用户提交的源代码进行编译、运行，同时又要完成大量Web请求的并发访问，所以系统对服务器系统的性能要求很高。 通过设计一个性能良好的系统，可以有效提高网站的高并发性和高可用性，保证服务器在高并发状态下处于稳定状态，满足大型程序设计竞赛及上机考试的需求。

### 3.2 需求收集

通过查阅相关文献、分析市场上的已有产品进行用户收集，并根据调查得到的同类产品用户的需求进行需求的分析和筛选，针对这些需求，列出了详细的功能需求和非功能需求，最终形成一套开发计划。

通过对目前已有的知名在线测试系统（如Leetcode，hihoCoder，HDOJ）进行调查分析发现，在提供题目信息时，需要提供题目描述、输入描述、输出描述、输入输出样例等，由于项目比较多，使用小标题的方法来展示比较直观。多数在线测试系统都提供了题目讨论区，方便用户之间可以进行讨论，学习数据结构和算法，以及改进自己代码中出现的问题。另外，有些网站由于建站较早，界面不够美观，在开发系统时需要注意界面的UI设计和交互设计。

在提供完善的功能和良好的交互的同时，系统还需要可靠的安全认证和授权协议，这样才能保证用户及系统的数据安全。除此之外，对于本系统而言，由于需要在服务器上运行用户提交的代码，而用户提交的代码有时是不安全的，它可能会无限创建进程或文件消耗评测机资源，或者建立到远程服务器的连接，给攻击者提供后面，因此系统需要对此进行一些限制已保证系统的安全。

### 3.3 功能需求分析

#### 3.3.1 角色权限

本系统是在线测试平台，应用场景主要为日常自主练习、编程课程作业、学科教学考试、程序设计竞赛等，该系统的主要使用人员分为用户和管理员两类，系统信息包括题目的基本信息、用户的基本信息、用户提交的代码等。用户可以注册、登录系统，完善个人信息，提交自己的源代码，查看历史提交记录，发布及回复讨论贴；管理员可以发布题目、更改已有题目的基本信息、删除已有题目，安排程序竞赛，管理员仅可在用户注册并由超级管理员授予相关权限后才能成为管理员；超级管理员拥有系统的全部权限，可以更改包括管理员在内的所有用户的信息，更改所有题目信息，授予及解除管理员权限，系统中只有一个超级管理员，在系统开发阶段产生，任何注册用户都不能成为超级管理员。

> 图 用户用例图

#### 3.3.2 模块功能

主要实现以下功能：注册与登录，题目列表页，题目详情页，发布与管理题目，代码评测。

(1) 注册与登录：系统为开放注册系统，任何人都可以注册成为本系统的用户。注册时要求用户ID为4至20位数字、字母、短横线或下划线组成的字符串，且不与系统数据库中已有注册用户ID相同，用户密码可由数字、字母以及除空格外的其它特殊字符组成，长度应不少于6位，过短的密码会影响账户安全，但同时应不超过30位。不符合规定的ID和密码将不能注册，同时系统会给出相应的警告提示。用户密码在系统数据库中会进行加密存储以加强安全性。

(2) 题目列表页：在题目目录页面中展示练习题库中的题目，默认按照题号进行升序排序，同时提供题目的难度、正确通过率信息，用户在登录后会展示该用户是否已正确完成该题目或是否已提交过源代码但是未正确完成。用户可以按照题目难易程度、正确通过率高低、用户是否已完成对题目进行自由排序。同时，系统在该界面提供一个搜索框，方便用户按题号或题目名称搜索练习题库中的题目。

(3) 题目详情页：每道题目的题目详情页面会显示题目的具体描述、输入格式、输出格式，并给出一个具体的输入样例和输出样例，同时会给出程序的运行时间限制以及程序最多可占用的内存限制。页面底部会提供本题目的源代码输入框，该输入框可以对代码进行语法高亮显示，用户须正确选择自己所使用的编程语言，目前系统支持对C、C++和Java语言进行在线评测。

(4) 发布与管理题目：管理员在登录后可以对练习题库和竞赛题库中的题目进行发布、更新题目相关描述及删除题目，发布新题目或更新时需要按照相关格式要求给出题目的全部信息，具体描述、输入格式、输出格式、输入样例、输出样例信息缺一不可，否则将不予通过。

(5) 代码评测：在用户提交源代码后，系统将编译并运行用户提交的代码，测试程序所使用的输入文件包含多组测试数据，存储在系统的文件系统中，编译过程在系统服务器的真机上运行，而运行过程将在沙盒环境中进行已保证系统的安全，程序运行后的输出文件将被拷贝至服务器真机，然后与标准输出结果进行比较。评测结束后系统会保存用户的源代码，并向用户返回评测结果。

### 3.4 非功能需求分析

通过对获取的需求进行分析后得到本系统需要具备以下几个非功能性需求：

1. 性能需求：对于已上传文件内容以及一些常见页面进行缓存处理，以保证其加载速度，并加快一般请求的响应速度。
2. 界面需求：本系统基本上都是通过 API 接口的形式提供给开发者，因此接口在设计上采用了 RESTful（Representational State Transfer表现层状态转化）架构，并采用了 JSON 样式的 API 响应类型。
3. 可维护性需求：本系统尽量将数据的操作放到 Model 层，以便于方法的复用，使代码更加易于维护并保持代码的整洁。

### 3.5 可行性研究

由于系统通常会受到资源、成本和时间等一系列因素的影响，所以需要对本系统进行可行性分析，以保证本系统能够在规定的时间内完成指定的需求。 

1. 技术可行性：随着计算机软件开发技术的不断发展与成熟，各个领域对信息化管理的需求也不断提升，衍生了许许多多性能稳定且便捷的Web开发工具，及良好的设计模式和开发理念，如前端框架Semantic UI、RESTful 架构等，为本次在线测试系统的设计与实现提供了良好的开发基础。本系统前端使用 HTML、CSS、JavaScript及Semantic UI框架进行开发，后端主要使用Go语言和Docker容器，并使用PostgreSQL作为系统数据库。这些都是性能稳定的软件开发工具与技术，使用这些工具与技术所开发的系统已在各个领域都得到了广泛的应用，软件开发厂商或技术社区提供了丰富详细的开发文档，方便开发人员学习和使用。
2. 经济可行性：本系统在开发过程中所使用的软件、框架及工具都是开源的，并且在投入使用之后无须人工成本，系统部署在了3台DigitalOcean云服务器上，费用总计为每月$15。
3. 法律可行性：本系统所使用的工具和框架都是 MIT 或 BSD 许可协议，使用者可以自由使用，只需带有原来代码中的相关许可协议即可。 

## 4 系统设计

### 4.1 总体设计

#### 4.1.1 C/S架构与B/S架构分析

 C/S（Client Server，客户端-服务器）架构是一种比较早的软件架构，主要用于局域网。它分为客户端和服务器两层，第一层是在客户机系统上结合了界面显示与业务逻辑，第二层是通过网络结合了数据库服务器。换言之， 此架构的第一层是用户表现层，第二层是数据库层。客户端不仅用于界面的显示，同时还需要处理一些运算及业务逻辑处理。 C/S架构的特点是，用户需要下载一个客户端才可使用该软件，比如Microsoft Office等。

 C/S架构的界面丰富且操作多样，界面内容可以任意排布以满足客户的需要。同时，由于只有两层的传输而不是中间有很多层，数据的安全性能够得到保障。但C/S架构同时也有一些缺点，例如适用面窄，通常用于局域网中，并且系统的维护成本高，一次升级需要人工更改所有客户端的程序。

> 图 C/S 架构

B/S（Browser/Server，浏览器-服务器）架构与C/S架构不同，其客户端不需要安装特定的软件，只需要通过浏览器即可，浏览器通过Web服务器与数据库进行交互，可以方便地在不同平台下工作；服务器端可采用高性能计算机，并安装Oracle等大型数据库。B/S架构分为三层，第一层表现层主要完成用户和后台的交互及最终查询结果的输出；第二层逻辑层是利用服务器完成客户端的应用逻辑功能；第三层数据层用于接受客户端请求后独立进行各种运算。

使用B/S架构时，无须安装或升级客户端，且系统可以直接发布在互联网上，交互性较强。B/S架构简化了客户端的工作，但该结构下服务器的工作较重，对服务器的性能要求更高。同时，在速度和安全性上需要花费巨大的设计成本，这是B/S架构最大的问题。

> 图 B/S架构

#### 4.1.2 REST架构

RESTful（REpresentational State Transfer），是目前最为流行的一种互联网软件架构。它指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful 的。因为它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。

REST的核心概念如下：

(1) 资源（Resources） REST是"表现层状态转化"，其实它省略了主语，"表现层"其实指的是"资源"的"表现层"，而我们平常上网访问的一张图片、一个文档、一个视频等就是资源。这些资源通过URI来定位，也就是一个URI表示一个资源。

(2) 表现层（Representation）资源是做一个具体的实体信息，它可以有多种的展现方式。而把实体展现出来就是表现层，例如一个txt文本信息，他可以输出成html、json、xml等格式，一个图片他可以jpg、png等方式展现，这个就是表现层的意思。URI确定一个资源，但是如何确定它的具体表现形式呢？应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对"表现层"的描述。

(3) 状态转化（State Transfer）访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，肯定涉及到数据和状态的变化。而HTTP协议是无状态的，那么这些状态肯定保存在服务器端，所以如果客户端想要通知服务器端改变数据和状态的变化，肯定要通过某种方式来通知它。
客户端能通知服务器端的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。

在REST架构中，每一个URI代表一种资源；客户端和服务器之间，传递这种资源的某种表现层；客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。

Web应用要满足REST最重要的原则是:客户端和服务器之间的交互在请求之间是无状态的,即从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外此请求可以由任何可用服务器回答，这十分适合云计算之类的环境。因为是无状态的，所以客户端可以缓存数据以改进性能。
另一个重要的REST原则是系统分层，这表示组件无法了解除了与它直接交互的层次以外的组件。通过将系统知识限制在单个层，可以限制整个系统的复杂性，从而促进了底层的独立性。

下图即是REST的架构图：

> 图 2.2.1 REST 架构图

当REST架构的约束条件作为一个整体应用时，将生成一个可以扩展到大量客户端的应用程序。它还降低了客户端和服务器之间的交互延迟。统一界面简化了整个系统架构，改进了子系统之间交互的可见性。REST简化了客户端和服务器的实现，而且对于使用REST开发的应用程序更加容易扩展。
下图展示了REST的扩展性：

> 图 2.2.2 REST的扩展性

#### 4.1.3 架构选择

结合本项目的实际需求考虑，为了使系统具有良好的便携性和可用性，且易于后期的系统维护和升级，本系统采用了B/S架构，全部的逻辑控制及数据存取操作都在服务器端进行，用户只需要浏览器即可使用本系统，无需使用特定的操作系统或软件。同时此方案也存在一些缺点，比如需要适配Chrome、Safari、IE等不同厂家的浏览器，以及服务器端的工作较重，对服务器的性能要求更高，在系统开发过程中需要重视。

传统的网页前后端是融合在一起的，比如之前的PHP，JSP等，在桌面时代没有出现问题，但是随着近年来移动互联网的发展，各种类型的客户端层出不穷，RESTful可以通过一套统一的接口为Web、iOS和Android提供服务。另外对于广大平台来说，比如Facebook platform、微博开放平台等，它们不需要有显示的前端，只需要一套提供服务的接口，于是RESTful架构就成为了更好的选择。由于RESTful架构具有耦合度低、性能稳定的特点，本系统服务器端采用了该架构模式进行设计。服务器提供的RESTful API中，URL只使用名词来指定资源，原则上不使用动词。该架构使用URI定位资源，用HTTP协议里的动词来实现资源的状态扭转，包括资源的添加、修改和删除等操作，用HTTP Status Code传递服务器的状态信息，比如200表示成功，500表示服务器内部错误等，限制了系统的复杂性，提高了可扩展性。

### 4.2 模块设计

#### 4.2.1 代码提交模块

用户在提交代码之前需要登录系统，然后选择源代码的文件类型，服务器端将会对其生成唯一编码并将代码以对应格式文件的形式保存在服务器的文件系统中，相应的存储位置将会被保存在服务器端的数据库中，以备查看。

| 请求地址         | 请求方式  | 功能                                 |
| ---------------- | --------- | ------------------------------------ |
| /problem?pid=1   | Post      | 向服务器端发送用户的源代码           |
| **请求参数**     | **类型**  | **内容**                             |
| pid              | int       | 所提交源代码对应的题号               |
| code             | string    | 源代码内容                           |
| ftype            | int       | 源代码类型                           |
| **返回参数**     | **类型**  | **内容**                             |
| rid              | uint64    | 存储于服务器端的源代码文件的唯一标识 |
| HTTP Status Code | const int | HTTP 状态码                          |

> 图 用户提交代码流程图

#### 4.2.2 评测模块

代码评测是系统的核心功能。首先在用户点击􏰀交按钮后，前端服务向后端服务(Executive)发出请 求，并将题目编号、用户所选编译器信息和用户代码􏰀交传到服务器后端;随后，后端服务调用执行器， 执行器与 Docker 交互，构建一个 Docker 容器，在 Docker 容器中执行预处理、编译运行等操作，对用 户代码程序进行运行资源限制是通过 Docker 官方􏰀供的 setrlimit ( ) 实现的，然后，调用 diff 将用户代 码的输出文件与正确的输出结果进行比较;最后，将结果发送至上层，上层再写入数据库，页面重定向至 代码结果页面并显示评测结果。 代码评测流程如下: 

![image-20180525161717827](/var/folders/l5/q_72mh6n0qb48d9q8fygnymm0000gn/T/abnerworks.Typora/image-20180525161717827.png)

图 代码评测流程图

a) Pre-Process:初始化 Docker，实现拉取镜像，创建容器等操作，完成将用户代码写入文件后将代 码文件拷入对应的容器中等准备工作。

b) Compile:将代码编译为可执行程序。

c) Run:在 Docker 容器中运行可执行程序，并收集输出。 用户代码正确与否首先是看用户代码能否正确编译并在规定的内存和时间内正确运行，如果编译失败， 

则直接返回编译错误;如果能够成功编译，但是在规定的时间内没有完成运行，则返回超时错误;如果用户程序请求比限制更多的内存，则返回超出内存错误。如果用户的代码能够正确编译并成功运行，将其输出结果与正确的输出结果进行比较，比较过程使用的是 Unix 的 diff 工具。每一个题目都包含多组测试数据，如果用户代码输出的结果与正确输出完全一致，则返回答案正确;如果用户代码的输出结果包含多余 的空格、Tab、换行或缺少相应的空格、Tab、换行，则返回格式错误;如果有任意一个测试样例的结果与正确输出不一致，则返回答案错误。 

#### 4.2.3 题目管理模块

管理员具有对系统中题库中的题目进行增、删、改的权限，新增题目或修改已有题目时需要符合系统要求，即所有项目需填写完整并且格式正确。下面已新建题目为例对题目管理模块的API接口进行说明。

表 新建题目的API接口设计

| 请求地址         | 请求方式               | 功能                 |
| ---------------- | ---------------------- | -------------------- |
| /dashboard       | Post                   | 向系统题库中新增题目 |
| **请求参数**     | **内容**               |                      |
| Pid              | 题号，是题目的唯一标识 |                      |
| Title            | 题目名称               |                      |
| Level            | 题目等级               |                      |
| Description      | 题目描述               |                      |
| Input            | 输入描述               |                      |
| Output           | 输出描述               |                      |
| SampleInput      | 输出样例               |                      |
| SampleOutput     | 输出样例               |                      |
| **返回参数**     | **内容**               |                      |
| HTTP Status Code | HTTP 状态码            |                      |
|                  |                        |                      |
|                  |                        |                      |



#### 4.2.4 登录注册模块

![image-20180524224804600](/var/folders/l5/q_72mh6n0qb48d9q8fygnymm0000gn/T/abnerworks.Typora/image-20180524224804600.png)

> 图 用户登录注册模块流程图

用户在填写ID和密码之后，系统会校验其是否符合要求。注册时所填写的ID需为4至20位的字母、数字或下划线，且不与系统中以后的ID重复，密码为6至30位的字符串，确认密码需要与此密码一致。登录时则需要输入数据库中已存在的ID和与之相匹配的密码。如果用户所填写的信息不符合要求，系统会提示相应的错误信息要求用户进行更改，直至符合要求，方可进入系统。

### 4.3 数据库设计

系统数据库E-R图如下：

![image-20180523232254636](/var/folders/l5/q_72mh6n0qb48d9q8fygnymm0000gn/T/abnerworks.Typora/image-20180523232254636.png)



## 5 系统实现

### 5.1 系统架构

为了使系统具有良好的便携性和可用性，且易于后期的系统维护和升级，本系统采用了B/S架构，全部的逻辑控制及数据存取操作都在服务器端进行，用户只需要浏览器即可使用本系统。同时，由于本系统存在高并发访问的需求，因此选择使用了三层服务器的模式，即负载均衡器-中间服务器-应用服务器-数据库，如下图所示。

![image-20180523224721373](/var/folders/l5/q_72mh6n0qb48d9q8fygnymm0000gn/T/abnerworks.Typora/image-20180523224721373.png)

暴露在外的不是真正的Web服务器的地址，而是负载均衡器的地址。系统流程如下：客户端向负载均衡器发起HTTP请求，负载均衡器能够将客户端的HTTP请求均匀的转发给Node服务器集群。Node服务器接到HTTP请求之后，能够对其进行解析，并且能够调用应用服务器暴露在外的RESTful API。应用服务器的RESTful API被调用后，对执行对应的暴露方法，如果有必要和数据库进行数据交互，应用服务器会在和数据库交互之后，将数据以JSON文件返回给Node，Node层将模板及数据组合渲染为HTML文件返回给反向代理服务器，反向代理服务器将对应的HTML文件返回给客户端。

这样的系统模式具有以下几个优点：Nginx 能够承受高并发的大量的请求，然后将这些请求均匀地转发给内部服务器，分摊压力；反向代理能够解决跨域引起的问题，因为Nginx服务器、Node服务器、应用服务器和数据库都处于内网段中；同时，Nginx非常擅长处理静态资源，如图像、视频、CSS文件、JavaScript文件等，所以也经常用作静态资源服务器，也就是CDN（Content Delivery Network，内容分发网络），比如前一个用户访问index.html，经过Nginx服务器、Node服务器、应用服务器、数据库链路之后，Nginx服务器会把index.html文件返回给用户，并且会把index.html缓存在Nginx服务器上，下一个用户再想访问index.html的时候，向Nginx服务器发出请求时，Nginx服务器发现本地有仍在有效期内的index.html缓存，于是就不用去请求Node层了，会直接将缓存的页面返回给用户。

### 5.2 详细实现方案

#### 5.2.1 并发的Socket通信



#### 5.2.1 Session和数据存储

在用户进入系统后的整个浏览过程中，由于HTTP协议是无状态的，所以用户的每一次请求都是无状态的。为了确定在整个Web操作过程中哪些连接与该用户有关，本系统使用了cookie和session机制，cookie机制是一种客户端机制，把用户数据保存在客户端，而session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息，每一个网站访客都会被分配给一个唯一的标志符，即session ID。

![6.1.cookie2](/Users/aym/Downloads/6.1.cookie2.png)

图 cookie原理图

![6.1.session](/Users/aym/Downloads/6.1.session.png)

图 session原理图

session的基本原理是由服务器为每个会话维护一份信息数据，客户端和服务端依靠一个全局唯一的标识来访问这份数据，以达到交互的目的。当用户访问Web应用时，服务端程序会随需要创建session，这个过程可以概括为三个步骤：

(1) 生成全局唯一标识符（session ID）；

(2) 开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失。所以为了解决这类问题，可以将会话数据写到文件里或存储在数据库中，当然这样会增加I/O开销，但是它可以实现某种程度的session持久化，也更有利于session的共享。从平衡安全和效率的角度考虑，将其保存在redis（REmote Dictionary Server）中，一个性能极高的开源的key-value数据库。

(3) 将session的全局唯一标示符发送给客户端。Cookie服务端通过设置Set-cookie头就可以将session的标识符传送到客户端，而客户端此后的每一次请求都会带上这个标识符，另外一般包含session信息的cookie会将失效时间设置为0（会话cookie），即浏览器进程有效时间。

表 创建session的函数设计

| 函数名称      |                     | 功能                                                  |
| ------------- | ------------------- | ----------------------------------------------------- |
| /SessionStart |                     | 为来访用户分配或获取与他相关联的session               |
| **传入参数**  | **类型**            | **内容**                                              |
| w             | http.ResponseWriter | 返回给客户端的写入内容                                |
| r             | *http.Request       | 客户端发来的请求                                      |
| **返回参数**  | **类型**            | **内容**                                              |
| session       | struct Session      | Session对象，包含全局唯一的Session ID和最后活动时间戳 |

#### 5.2.2 系统日志实现

日志在程序开发与系统部署与维护中起着重要的作用，通过日志可以记录调试信息与用户活动。本系统使用的日志设计部署思路来自于seelog，对日志信息进行了分级，根据不同的等级输出不同的日志，在程序开发中设置等级低一点，部署的时候把等级设置高，这样开发中的调试信息可以屏蔽掉。日志模块比较轻量级，采用了系统的log.Logger接口，默认输出到os.Stdout，详细的实现如下所示：

```
// Log levels to control the logging output.
const (
    LevelTrace = iota
    LevelDebug
    LevelInfo
    LevelWarning
    LevelError
    LevelCritical
)

// logLevel controls the global log level used by the logger.
var level = LevelTrace

// LogLevel returns the global log level and can be used in
// own implementations of the logger interface.
func Level() int {
    return level
}

// SetLogLevel sets the global log level used by the simple
// logger.
func SetLevel(l int) {
    level = l
}
```

此段代码实现了日志模块的日志分级，初始级别是Trace，通过调用SetLevel函数可以设置不同的分级。

### 5.3 系统安全与防护 

#### 5.3.1 沙盒机制 

一般的评测系统都会限制程序的运行资源，如内存、时间用量，进程、线程数量。资源的限制通常使用 setrlimit(Set Resource Limit)来完成。setrlimit 限制的时间(RLIMIT_RTTIME)是 CPU 时间，而线程被挂起的时间并不计算在内，如调用 sleep 时的延时和 scanf 等待用户输入的时间。为了正确限制目标程序的时间，系统将会创建一个监视线程，在指定的时间后将目标进程杀死。关于对用户程序对系统调用的限制，目前常用的两个限制系统调用的方案是 ptrace 和 seccamp，前者的原理是在目标程序每次尝试进行系统调用时通知评测程序，如果发现危险的系统调用，可以及时将目标程序杀死。但 ptrace 在每次系统调用时都会产生两次中断进入系统调用前一次，系统调用返回后一次，影响效率。相比之下 seccamp 可能是更好的选择。 

保护系统安全的另一种方法是将目标程序与系统环境隔离，形成一个沙盒（Sandbox）环境。如 chroot 可以保证程序只能访问某个目录下的内容，而 Docker 则可以实现完全隔离的容器。每次运行目标程序时，创建一个 Docker 容器，将输入数据与目标程序的可执行文件传入，创建一个监视进程，fork 出子进程调用 setrlimit 后使用 exec 载入目标程序。 

#### 5.3.2 预防 CSRF 攻击

通过跨站请求伪造 CSRF(Cross-site request forgery)，攻击者可以盗用用户的登录信息，以用户的身份模拟发送各种请求。CSRF 攻击主要是因为 Web 的隐士身份验证机制，Web 的身份验证机制虽然可以保证 一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。CSRF 的防御可以从服务 器和客户端两方面着手，防御效果是从服务端着手效果比较好。本系统服务端对 CSRF 攻击的预防主要从 以下两个方面入手。 

a) 正确使用 GET, POST 和 Cookie。限定修改只能使用 POST，当 GET 方式请求时就拒绝响应。通过这种方式，可以防止 GET 方式的 CSRF 攻击。 

b) 在非 GET 请求中增加伪随机数。为每个用户生成一个唯一的 cookie token，所有表单都包含同一 个伪随机值。因为攻击者理论上不能获得第三方的 Cookie，所以表单中的数据也就构造失败，但是由于用 户的 Cookie 很容易由于网站的 XSS 漏洞而被盗取，所以这个方案必须要在没有 XSS 的情况下才安全。 

#### 5.3.3 避免 XSS 攻击

跨站脚本攻击 XSS(Cross-Site Scriping) 是一种常见的 web 安全漏洞，它允许攻击者将恶意代码植入到􏰀供给其它用户使用的页面中。Web 应用未对用户􏰀交请求的数据做充分的检查过滤，允许用户在􏰀交的 数据中掺入 HTML 代码(最主要的是“>”、“<”)，并将未经转义的恶意代码输出到第三方用户的浏览器解释 执行，是导致 XSS 漏洞的产生原因。本系统通过过滤用户输入来避免 XSS 攻击，主要方式有以下两种: 

a) 过滤特殊字符。将用户所􏰀供的内容进行过滤，Go 语言􏰀供了 HTML 的过滤函数:text/template 包下面的 HTMLEscapeString、JSEscapeString 等函数

 b) 使用 HTTP 头指定类型。这样就可以让浏览器解析 javascript 代码，而不会是 html 输出。 

#### 5.3.4 存储密码

目前用的最多的密码存储方案是将明文密码做单向哈希后存储，容易被黑客使用 rainbow table 破解。 

本系统采用加盐(salt)的方式来存储密码，算法过程如下:先将用户输入的密码进行一次 MD5 加密，再 将得到的 MD5 值前后加上随机字符串，再进行一次 MD5 加密。这个随机字符串为用户名加上一段只有系统管理员知道的固定字符串。 

## 6 系统测试



## 7 总结与展望

经过多个版本的迭代和多次重构，支持高并发的在线代码测试系统已基本实现，达到了任务书的要求，实现了需求中所罗列的大部分设计和功能。在开发过程中，面对不同的语言、框架和工具时，根据系统需求，选择与需求相匹配的工具来进行开发是非常重要的。本系统从支持高并发的角度考虑，主要使用 Go 语言进行开发。而出于安全考虑，代码评测功能在 Docker 容器中 进行。主要优势如下: 

a) 并发编程是 Go 语言的优势，轻量级的 gorouine 比传统线程更容易实现高并发。goroutine 比线程更 小，十几个 goroutine 体现在底层可能就是五六个线程。Go 语言内部已经实现了这些 goroutine 之间的内存 共享，执行 goroutine 只需大概 4~5KB 的极少的栈内存，并且栈内存会根据相应的数据伸缩。栈扩容采用 的是连续栈(Contiguous Stack)，栈空间不足的时候申请一个 2 倍于当前大小的新栈，并把所有数据拷贝 到新栈， 接下来的所有调用执行都发生在新栈上。也正因为如此，可同时运行成千上万个并发任务。 goroutine 比 thread 更易用、更高效、更轻便。 

b) 传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核， 无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署 的时间。由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟 机技术，一个相同配置的主机，往往可以运行更多数量的应用。 

由于时间仓促，系统仍然存在疏漏之处和改进空间。比如，在整个系统代码编写中，很多公共部分没有很好的抽离，代码的规范还需要进一步地提升。同时，数据库的表设计还存在很多欠缺的地方。在日后的学习中，需要不断学习新的知识，对自己的不足之处进行改进。

## 参考文献

1. 作为前端需要了解的B/S架构 https://juejin.im/entry/58158fb12e958a00549ab754
2. Redis 简介 http://www.runoob.com/redis/redis-intro.html
3. 理解RESTful架构 http://www.ruanyifeng.com/blog/2011/09/restful.html